@model Grammar
{{
    var settings = model.Settings.ToLookup(s => s.Key.Name, s => s.Value);
    var assemblyName = Assembly.GetExecutingAssembly().GetName();
}}
// -----------------------------------------------------------------------
// <auto-generated>
//   This code was generated by {{= assemblyName.Name }} {{= assemblyName.Version }}
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
// </auto-generated>
// -----------------------------------------------------------------------

{{
    var allFlags = new HashSet<string>(model.Rules.SelectMany(r => r.Flags.Select(f => f.Name)));
    var hasMemoized = allFlags.Contains("memoize");
    var hasLexical = allFlags.Contains("lexical");
    var hasPublic = allFlags.Contains("public");
    var hasExported = allFlags.Contains("export");
    var @namespace = settings["namespace"].SingleOrDefault() ?? "Parsers";
    var classname = settings["classname"].SingleOrDefault() ?? "Parser";
    var accessibility = settings["accessibility"].SingleOrDefault() ?? "public";
    var resources = settings["resources"].SingleOrDefault();
    var startRule = settings["start"].Select(n => n.ToString()).SingleOrDefault();

    if (startRule == null && !hasPublic && !hasExported)
    {
        startRule = model.Rules[0].Identifier.Name;
    }
}}
namespace
{{@RenderCode @namespace}}
{
    using System;
    using System.Collections.Generic;
    using Pegasus.Common;
    {{each @using in settings["using"]}}
        using
            {{@RenderCode @using}}
            ;
    {{/each}}
    {{if resources != null}}
        using ParserResources =
            {{@RenderCode resources}}
            ;
    {{/if}}

    /// <summary>
    ///  Parses a string according to the rules of the <see cref="{{= classname }}" /> grammar.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("{{= assemblyName.Name }}", "{{= assemblyName.Version }}")]
    {{@RenderCode accessibility}}
    partial class
    {{@RenderCode classname}}
    {
        {{each members in settings["members"]}}
            {{@RenderCode members}}
        {{/each}}
        {{if hasMemoized}}
            private Dictionary<CacheKey, object> storage;
        {{/if}}
        {{if hasExported}}

            private ExportedRules exported;

            /// <summary>
            /// Gets the set of rules exported by this parser.
            /// </summary>
            public ExportedRules Exported
            {
                get
                {
                    return this.exported ?? (this.exported = new ExportedRules(this));
                }
            }
        {{/if}}
        {{if startRule != null}}
            {{
                var type = this.types[model.Rules.Single(r => r.Identifier.Name == startRule).Expression];
            }}

            /// <summary>
            ///  Parses a string according to the rules of the <see cref="{{= classname }}" /> grammar.
            /// </summary>
            /// <param name="subject">The parsing subject.</param>
            /// <param name="fileName">The optional file name to use in error messages.</param>
            /// <returns>The <see cref="{{= type.ToString().Replace("<", "{").Replace(">", "}") }}" /> parsed from <paramref name="subject" />.</returns>
            /// <exception cref="FormatException">
            ///  Thrown when parsing fails against <paramref name="subject"/>.  The exception's <code>Data["cursor"]</code> will be set with the cursor where the fatal error occurred.
            /// </exception>
            {{if hasLexical}}
                public {{= type }} Parse(string subject, string fileName = null)
                {
                    IList<LexicalElement> lexicalElements;
                    return this.Parse(subject, fileName, out lexicalElements);
                }

                /// <summary>
                ///  Parses a string according to the rules of the <see cref="{{= classname }}" /> grammar.
                /// </summary>
                /// <param name="subject">The parsing subject.</param>
                /// <param name="fileName">The optional file name to use in error messages.</param>
                /// <param name="lexicalElements">When this method returns, contains the lexical elements for the parsing subject. This parameter is passed uninitialized.</param>
                /// <returns>The <see cref="{{= type.ToString().Replace("<", "&lt;").Replace(">", "&gt;") }}" /> parsed from <paramref name="subject" />.</returns>
                /// <exception cref="FormatException">
                ///  Thrown when parsing fails against <paramref name="subject"/>.  The exception's <code>Data["cursor"]</code> will be set with the cursor where the fatal error occurred.
                /// </exception>
            {{/if}}
            public {{= type }} Parse(string subject, string fileName{{if !hasLexical}} = null{{else}}, out IList<LexicalElement> lexicalElements{{/if}})
            {
                var cursor = new Cursor(subject, 0, fileName);
                return this.StartRuleHelper(cursor, this.{{= startRule }}, "{{= startRule }}"{{if hasLexical}}, out lexicalElements{{/if}}).Value;
            }
        {{/if}}
        {{each rule in model.Rules.Where(r => r.Flags.Any(f => f.Name == "public"))}}
            {{
                var type = this.types[rule.Expression];
                var publicName = "Parse" + rule.Identifier.Name.Substring(0, 1).ToUpper() + rule.Identifier.Name.Substring(1);
            }}

            /// <summary>
            ///  Parses a string according to the format of the <c>{{= rule.Identifier.Name }}</c> rule.
            /// </summary>
            /// <param name="subject">The parsing subject.</param>
            /// <param name="fileName">The optional file name to use in error messages.</param>
            /// <returns>The <see cref="{{= type.ToString().Replace("<", "{").Replace(">", "}") }}" /> parsed from <paramref name="subject" />.</returns>
            /// <exception cref="FormatException">
            ///  Thrown when parsing fails against <paramref name="subject"/>.  The exception's <code>Data["cursor"]</code> will be set with the cursor where the fatal error occurred.
            /// </exception>
            {{if hasLexical}}
                public {{= type }} {{: publicName }}(string subject, string fileName = null)
                {
                    IList<LexicalElement> lexicalElements;
                    return this.{{: publicName }}(subject, fileName, out lexicalElements);
                }

                /// <summary>
                ///  Parses a string according to the format of the <c>{{= rule.Identifier.Name }}</c> rule.
                /// </summary>
                /// <param name="subject">The parsing subject.</param>
                /// <param name="fileName">The optional file name to use in error messages.</param>
                /// <param name="lexicalElements">When this method returns, contains the lexical elements for the parsing subject. This parameter is passed uninitialized.</param>
                /// <returns>The <see cref="{{= type.ToString().Replace("<", "&lt;").Replace(">", "&gt;") }}" /> parsed from <paramref name="subject" />.</returns>
                /// <exception cref="FormatException">
                ///  Thrown when parsing fails against <paramref name="subject"/>.  The exception's <code>Data["cursor"]</code> will be set with the cursor where the fatal error occurred.
                /// </exception>
            {{/if}}
            public {{= type }} {{: publicName }}(string subject, string fileName{{if !hasLexical}} = null{{else}}, out IList<LexicalElement> lexicalElements{{/if}})
            {
                var cursor = new Cursor(subject, 0, fileName);
                return this.StartRuleHelper(cursor, this.{{= rule.Identifier.Name }}, "{{= rule.Identifier.Name }}"{{if hasLexical}}, out lexicalElements{{/if}}).Value;
            }
        {{/each}}

        {{@WalkGrammar model}}
        private IParseResult<T> StartRuleHelper<T>(Cursor cursor, ParseDelegate<T> startRule, string ruleName{{if hasLexical}}, out IList<LexicalElement> lexicalElements{{/if}})
        {
            {{if hasMemoized}}
                try
                {
                    this.storage = new Dictionary<CacheKey, object>();
                    var result = startRule(ref cursor);
                    if (result == null)
                    {
                        throw ExceptionHelper(cursor, state => "Failed to parse '" + ruleName + "'.");
                    }
                    {{if hasLexical}}
                        var lexical = (cursor["_lexical"] as ListNode<LexicalElement>).ToList();
                        lexical.Reverse();
                        lexicalElements = lexical.AsReadOnly();
                    {{/if}}
                    return result;
                }
                finally
                {
                    this.storage = null;
                }
            {{else}}
                var result = startRule(ref cursor);
                if (result == null)
                {
                    throw ExceptionHelper(cursor, state => "Failed to parse '" + ruleName + "'.");
                }
                {{if hasLexical}}
                    var lexical = (cursor["_lexical"] as ListNode<LexicalElement>).ToList();
                    lexical.Reverse();
                    lexicalElements = lexical.AsReadOnly();
                {{/if}}
                return result;
            {{/if}}
        }

        private IParseResult<string> ParseLiteral(ref Cursor cursor, string literal, bool ignoreCase = false{{if hasLexical}}, string ruleName = null{{/if}})
        {
            if (cursor.Location + literal.Length <= cursor.Subject.Length)
            {
                var substr = cursor.Subject.Substring(cursor.Location, literal.Length);
                if (ignoreCase ? substr.Equals(literal, StringComparison.OrdinalIgnoreCase) : substr == literal)
                {
                    var endCursor = cursor.Advance(substr.Length);
                    var result = this.ReturnHelper<string>(cursor, ref endCursor, state => substr{{if hasLexical}}, ruleName{{/if}});
                    cursor = endCursor;
                    return result;
                }
            }
            return null;
        }

        private IParseResult<string> ParseClass(ref Cursor cursor, string characterRanges, bool negated = false, bool ignoreCase = false{{if hasLexical}}, string ruleName = null{{/if}})
        {
            if (cursor.Location + 1 <= cursor.Subject.Length)
            {
                var c = cursor.Subject[cursor.Location];
                bool match = false;
                for (int i = 0; !match && i < characterRanges.Length; i += 2)
                {
                    match = c >= characterRanges[i] && c <= characterRanges[i + 1];
                }
                if (!match && ignoreCase && (char.IsUpper(c) || char.IsLower(c)))
                {
                    var cs = c.ToString();
                    for (int i = 0; !match && i < characterRanges.Length; i += 2)
                    {
                        var min = characterRanges[i];
                        var max = characterRanges[i + 1];
                        for (char o = min; !match && o <= max; o++)
                        {
                            match = (char.IsUpper(o) || char.IsLower(o)) && cs.Equals(o.ToString(), StringComparison.CurrentCultureIgnoreCase);
                        }
                    }
                }
                if (match ^ negated)
                {
                    var endCursor = cursor.Advance(1);
                    var substr = cursor.Subject.Substring(cursor.Location, 1);
                    var result = this.ReturnHelper<string>(cursor, ref endCursor, state => substr{{if hasLexical}}, ruleName{{/if}});
                    cursor = endCursor;
                    return result;
                }
            }
            return null;
        }

        private IParseResult<string> ParseAny(ref Cursor cursor{{if hasLexical}}, string ruleName = null{{/if}})
        {
            if (cursor.Location + 1 <= cursor.Subject.Length)
            {
                var substr = cursor.Subject.Substring(cursor.Location, 1);
                var endCursor = cursor.Advance(1);
                var result = this.ReturnHelper<string>(cursor, ref endCursor, state => substr{{if hasLexical}}, ruleName{{/if}});
                cursor = endCursor;
                return result;
            }
            return null;
        }

        private IParseResult<T> ReturnHelper<T>(Cursor startCursor, ref Cursor endCursor, Func<Cursor, T> wrappedCode{{if hasLexical}}, string ruleName = null{{/if}})
        {
            {{if hasLexical}}
                if (ruleName != null)
                {
                    var state = endCursor.WithMutability(true);
                    var element = new LexicalElement { StartCursor = startCursor, EndCursor = endCursor, Name = ruleName };
                    state["_lexical"] = (state["_lexical"] as ListNode<LexicalElement>).Push(element);
                    element.EndCursor = endCursor = state.WithMutability(false);
                }
            {{/if}}
            var result = wrappedCode(endCursor);
            var lexical = result as ILexical;
            if (lexical != null && lexical.StartCursor == null && lexical.EndCursor == null)
            {
                lexical.StartCursor = startCursor;
                lexical.EndCursor = endCursor;
            }
            return new ParseResult<T>(startCursor, endCursor, result);
        }

        private IParseResult<T> ParseHelper<T>(ref Cursor cursor, ParseDelegate<T> wrappedCode{{if hasLexical}}, string ruleName = null{{/if}})
        {
            var startCursor = cursor;
            var result = wrappedCode(ref cursor);
            if (result == null)
            {
                cursor = startCursor;
                return null;
            }
            else
            {
                cursor = cursor.WithMutability(false);
                {{if hasLexical}}
                    if (ruleName != null)
                    {
                        var state = cursor.WithMutability(true);
                        var element = new LexicalElement { StartCursor = startCursor, EndCursor = cursor, Name = ruleName };
                        state["_lexical"] = (state["_lexical"] as ListNode<LexicalElement>).Push(element);
                        element.EndCursor = cursor = state.WithMutability(false);
                    }

                {{/if}}
                return result;
            }
        }

        private Exception ExceptionHelper(Cursor cursor, Func<Cursor, string> wrappedCode)
        {
            var ex = new FormatException(wrappedCode(cursor));
            ex.Data["cursor"] = cursor;
            return ex;
        }

        private T ValueOrDefault<T>(IParseResult<T> result)
        {
            return result == null
                ? default(T)
                : result.Value;
        }
        {{if hasExported}}

            /// <summary>
            /// Defines the set of rules exported by this parser.
            /// </summary>
            public sealed class ExportedRules
            {
                private {{= classname }} parser;

                internal ExportedRules({{= classname }} parser)
                {
                    this.parser = parser;
                }
                {{each rule in model.Rules.Where(r => r.Flags.Any(f => f.Name == "export"))}}
                    {{
                        var type = this.types[rule.Expression].ToString();
                        var publicName = rule.Identifier.Name.Substring(0, 1).ToUpper() + rule.Identifier.Name.Substring(1);
                    }}

                    /// <summary>
                    ///  Executes the <c>{{: publicName }}</c> rule and advances the cursor.
                    /// </summary>
                    /// <returns>
                    ///  A parse result containing the parsed <see cref="{{= type.Replace("<", "{").Replace(">", "}") }}"/> if the parse was successful, <c>null</c> otherwise.
                    /// </returns>
                    public IParseResult<{{= type }}> {{: publicName }}(ref Cursor cursor)
                    {
                        return this.parser.{{: rule.Identifier.Name }}(ref cursor);
                    }
                {{/each}}
            }
        {{/if}}
    }
}
